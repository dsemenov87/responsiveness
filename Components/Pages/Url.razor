@page "/uri/{encodedUri}"
@rendermode InteractiveServer
@using System.Net
@using responsiveness.CommonServices
@using responsiveness.Components.Models
@using responsiveness.Models
@inject UriMonitoringModel Model
@inject IStatsCalculator StatsCalculator

<PageTitle>URL statistics</PageTitle>

<h2>@DecodeUri(EncodedUri!)</h2>
<hr/>

<section class="chart-panel">
    <LinePlot Settings="@_responseTimeSettings"></LinePlot>
    <div class="chart-right">
        <table class="table">
            <thead>
            <tr>
                <th>Stage</th>
                <th>Time, ms</th>
            </tr>
            </thead>
            <tbody>
            @foreach (var (stage, time) in _networkData)
            {
            <tr>
                <td>@stage.ToString()</td>
                <td>@time</td>
            </tr>
            }
            </tbody>
        </table>
    </div>
</section>
<hr/>
<section class="chart-panel">
    <LinePlot Settings="@_errorsSettings"></LinePlot>
</section>

@code {
    [Parameter]
    public string? EncodedUri { get; set; }

    private static Uri DecodeUri(string encodedUri) => new(WebUtility.UrlDecode(encodedUri));

    private readonly LinePlotSettings _responseTimeSettings = new()
    {
        ElementId = "responseTime",
        Title = "URL response time",
        Width = 600,
        Height = 350,
        HtmlClass = "chart-left",
    };

    private readonly LinePlotSettings _errorsSettings = new()
    {
        ElementId = "errors",
        Title = "URL errors total count",
        Width = 600,
        Height = 350,
        HtmlClass = "chart-left",
    };

    private readonly Dictionary<HttpRequestStage, double> _networkData = new();

    protected override void OnInitialized()
    {
        var uri = DecodeUri(EncodedUri!);
        var process = Model[uri];
        _responseTimeSettings.Data.AddRange(GetResponseTimePlotData(process));
        _errorsSettings.Data.AddRange(GetErrorsPlotData(process));
        UpdateNetworkData(process);
    }

    private IEnumerable<LinePlotData> GetResponseTimePlotData(UriMonitoringProcess process)
    {
        foreach (var measurement in process.Measurements)
        {
            var time = (measurement.Timestamp - Model.StartTime).TotalMilliseconds / 1_000;
            var metrics = measurement.MetricsList.FirstOrDefault(m => m.Stage == HttpRequestStage.TotalRequest);
            if (metrics is null) continue;
            
            yield return new LinePlotData { MetricName = "Mean", N = metrics.Mean, Timestamp = time };
            yield return new LinePlotData { MetricName = "StdDev", N = metrics.StdDev, Timestamp = time };
            yield return new LinePlotData { MetricName = "Median", N = metrics.Median, Timestamp = time };
        }
    }

    private IEnumerable<LinePlotData> GetErrorsPlotData(UriMonitoringProcess process)
    {
        var counter = 0;
        foreach (var errorTime in process.Errors)
        {
            var time = (errorTime - Model.StartTime).TotalMilliseconds / 1_000;
            yield return new LinePlotData { MetricName = "Error", N = ++counter, Timestamp = time };
        }
    }
    
    private void UpdateNetworkData(UriMonitoringProcess process)
    {
        var data = new Dictionary<HttpRequestStage, List<double>>();
        foreach (var measurement in process.Measurements)
        {
            var time = (measurement.Timestamp - Model.StartTime).TotalMilliseconds / 1_000;
            foreach (var metrics in measurement.MetricsList)
            {
                if (data.TryGetValue(metrics.Stage, out var value))
                    value.Add(metrics.Median);
                else
                {
                    var newList = new List<double>(1024) { metrics.Median };
                    data.Add(metrics.Stage, newList);
                }
            }
        }

        _networkData.Clear();
        foreach (var (stage, measurements) in data)
        {
            _networkData.Add(stage, StatsCalculator.Median(measurements));
        }
    }
}
